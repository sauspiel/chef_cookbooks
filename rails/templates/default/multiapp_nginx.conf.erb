upstream unicorn_server {
 server unix:/var/run/unicorn/unicorn.sock fail_timeout=0;
}

server {  
  listen 80;
  server_name <%= @server_name %>;
  set $domain <%= @server_name %>;
  set $app <%= @app_name %>; 

  # Don't serve images from other apps
  # Must come before includes
  location ~ ^/images/(<%= @other_apps %>)/ {
    return 404;
  }

  include /etc/nginx/sites-include/rails-common.conf;

  location @rails {

    include /etc/nginx/common/proxy.conf;

    # We never want http hitting rails
    rewrite ^ https://$domain$request_uri permanent;
  }
}

server {
  listen 443;
  server_name <%= @server_name %>;
  set $domain <%= @server_name %>;
  set $app <%= @app_name %>; 

  # Don't serve images from other apps
  # Must come before includes
  location ~ ^/images/(<%= @other_apps %>)/ {
    return 404;
  }

  ssl on;
  ssl_certificate /etc/ssl_certs/<%=  @server_name %>.crt;
  ssl_certificate_key /etc/ssl_certs/<%=  @server_name %>.key;

  # for PCI compliance
  ssl_protocols SSLv3 TLSv1;
  ssl_ciphers ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:-LOW:-SSLv2:-EXP;

  include /etc/nginx/sites-include/rails-common.conf;

  location @rails {    
    include /etc/nginx/common/proxy.conf;
    proxy_set_header X_FORWARDED_PROTO https;
    proxy_pass http://unicorn_server;
  }
}

# The better way to "catch" and rewrite domains
# http://wiki.nginx.org/Pitfalls
# Rule 1) No using ifs, use server blocks
# Rule 2) Specify this is a catch_all with "default_server"
# Rule 3) Forget rewrites, just return a 301
server {
  listen 80 default_server;
  return 301 $scheme://<%= @node[:rails][:default_domain] %>$request_uri;
}

server {
  listen 443 default_server;
  return 301 $scheme://<%= @node[:rails][:default_domain] %>$request_uri;

  ssl on;
  ssl_certificate /etc/ssl_certs/<%=  @server_name %>.crt;
  ssl_certificate_key /etc/ssl_certs/<%=  @server_name %>.key;
  ssl_verify_depth 3;
}

