server_name_in_redirect off;

root /var/www/$domain/current/public;

# logs in a consistent place
access_log /var/log/nginx/$domain.access.log;

location / {
  # Our new best friend, lets check for files/cache before sending to proxy
  # Our last stop is the internal location @rails
  try_files $uri/index.html $uri.html $uri @rails;
}

# Set correct expires/cache headers for static files
location ~ ^/(uploads|images|versioned_assets|assets|sounds|rsls|swfs) {
  expires max;
  add_header  Cache-Control public;
  # We again use try_files (and not an evil if) and 404 instead of going to rails
  try_files $uri =404;
  break; # SHOULD serve images when maint page is up (but doesn't)
}

include /etc/nginx/helpers/expires.conf;
include /etc/nginx/helpers/invalid_requests.conf;

# Check for the existence of a 503.html — if it is there, we are in maint mode
#
# We can't avoid an evil "if" statement here http://wiki.nginx.org/IfIsEvil
# Essentially to return a 503, we need to test on each request
recursive_error_pages on;

if (-f $document_root/error_pages/$app/503.html){
  return 503;
}

error_page 404 /error_pages/$app/404.html; 
error_page 500 /error_pages/$app/500.html; 
error_page 502 /error_pages/$app/502.html; 
error_page 504 /error_pages/$app/504.html; 

error_page 503 @503;

location @503 {
  # ok I give up, lets use an evil if
  if (-f $request_filename){
   break;
  }
  rewrite ^ /error_pages/$app/503.html break;
}
